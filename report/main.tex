\documentclass[12pt,a4paper]{article}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{aeguill}
\usepackage{pbox}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{mathtools}
\usepackage{bmpsize}
\usepackage[toc,page]{appendix}
\linespread{1}

\begin{document}
\everymath{\displaystyle}
\pagenumbering{arabic}
\setcounter{page}{1}

\begin{titlepage}
	\begin{center}
		\hfill \break
		\hfill \break
		\includegraphics[scale = 0.35]{logo}~\\[1cm]
		\textsc{\LARGE Instituto Superior Técnico}\\[0.25cm]
		\textsc{\Large Mestrado Integrado em Engenharia Electrotécnica e de Computadores}\\[1.8cm]
		\textsc{\huge Algoritmia e Desempenho Em Redes de Computadores}\\[0.25cm]
		{\huge \bfseries  Conectividade na Internet\\[1cm]}
		\begin{tabular}{ l l }
			David Fialho & \hspace{2mm} n.º 73530 \\
			Nuno Mendes & \hspace{2mm} n.º 73716 
		\end{tabular}
		\vfill
		{\large Lisboa, 4 de Dezembro de 2015}
	\end{center}
\end{titlepage}

\pagebreak

\section{O Problema}

Neste relatório é descrito um procedimento para calcular o número mínimo de nós retirados que impeça a rede de permanecer ligada. Para a resolução do problema é descrito um procedimento que funciona para qualquer grafo genérico.

A conectividade da rede é um parâmetro global desta e por isso, pode ser descrita como o mínimo número de nós removidos que separa um par fonte-destino dessa rede, no conjunto de todos os pares possíveis.

\section{Connectividade entre um par de nós}

Dada uma rede com ligações bidirecionais, o problema de encontrar o menor número de nós que separa um par de nós é equivalente a encontrar o número de caminhos disjuntos entre os mesmos. Neste caso considera-se caminhos disjuntos aqueles que não têm nenhum nó em comum exceto os nós fonte e destino.

O problema de determinar o número de caminhos disjuntos, em termos de arestas, entre dois nós para um grafo com ligações direcionadas pode ser traduzido por um problema de fluxos máximos em que todas as ligações têm capacidade unitária. 

No caso do problema em questão, este pode ser reduzido ao mesmo problema transformando as ligações bidirecionais em duas ligações com sentidos inversos de forma a converter o grafo da rede num digrafo e aplicando a técnica de \textit{vertex-splitting} de forma a reduzir um problema de nós a um problema de ligações. Nesta técnica, cada nó é dividido em 2 sub-nós: nó negativo e nó positivo; ligados entre si, do nó negativo para o positivo, por uma ligação de capacidade unitária; todas as ligações de entrada do supernó entram apenas no nó negativo e todas as ligações de saída saem apenas do nó positivo. Este problema pode então ser modulado como um problema de fluxos máximos fazendo uso de um método bem conhecido: método de Ford-Fulkerson. O método de Ford-Fulkerson foi implementado (Algoritmo \ref{alg:residual_network} com recurso a um BFS para encontrar os caminhos entre o par de nós em cada iteração. Esta implementação é conhecida como o algoritmo de Edmonds-Karp.

Embora o problema possa ser resolvido com ligações todas de capacidade unitária, considerando as capacidades das ligações entre supernós infinitas é garantido que na última iteração do algoritmo o corte encontrado se encontre na ligação entre os sub-nós dos nós que separam o par de nós em questão. Esta propriedade é utilizada mais à frente.

\begin{algorithm}
\caption{Algoritmo BFS que procura um caminho entre o nó fonte \textit{s} e o destino \textit{t}.}\label{alg:bfs_goal}
\begin{algorithmic}[1]
\Procedure{GetPath}{$graph, source, goal$}
	\For{each node $n$ in $graph$}
    	\State {mark all nodes in $graph$ as not $visited$}
    	\State {mark all nodes' $parent$ as $None$}
    \EndFor
    \State $Queue :=  \{source\}$
  	\While{there is a $node$ in $Queue$}
      \State {select first node $u$ from $Queue$}
      \If{$u$ is $goal$}
      		\Return parent 
      \EndIf
      \For{each $link$ in $Links(u)$}
      		\State {select tail node $v$ from $link$}
        	\If{$capacity(link)$ is $positive$ and $v$ not $visited$}
        		\State {mark $v$ as $visited$}
        		\State {mark $u$ as $parent$ of $v$}
            	\State {$Queue := Queue \cup \{v\}$}
            \EndIf
      \EndFor
  	\EndWhile
  	\Return $NULL$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Algoritmo Edmonds-Karp que calcula o fluxo máximo da rede.}\label{alg:residual_network}
\begin{algorithmic}[1]
\Procedure{MaximumFlow}{$graph, source, goal$}
    \State $maxflow := 0 $
    \State $path := GetPath(graph,source,goal)$
  	\While{there is a disjoint $path$ in $graph$}
      \For{each $link$ in $path$}
      		\State subtract 1 from $link$ capacity
        	\State add 1 to $inverted(link)$ capacity
      \EndFor
      \State add 1 to $maxflow$
      \State $path := GetPath(graph,source,goal)$
  	\EndWhile
  	\Return $maxflow$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Para um grafo com n nós e m ligações, em cada iteração é calculado um caminho aumentativo através de uma BFS com complexidade de $O(m)$ e pelo menos uma das $m$ ligações ao longo desse caminho fica saturada. Dado que os caminhos encontrados por uma BFS são de comprimento crescente em relação ao nó fonte, a distância da ligação saturada a esse mesmo nó é sempre superior à distância que esta tinha anteriormente. A distância de uma ligação ao nó fonte é limitada pelo número de nós $n$. Sendo assim, o algoritmo tem no máximo $nm$ iterações, no caso em que todas ligações são saturadas até ao seu valor máximo. Isto significa que a complexidade do algoritmo é de $O(nm^2)$.

\section{Distribuição cumulativa das conectividades entre todos os pares de nós}

Para resolver este problema, foi executado o algoritmo $MaximumFlow$ para todos os pares de nós diferentes existentes no grafo, com a seguinte regra: se para separar o par (\textit{s}, \textit{t}) é preciso remover \textit{k} nós, então também é preciso remover a mesma quantidade de nós para o par (\textit{t}, \textit{s}), pois o grafo não é direcionado. Assim, não é preciso determinar \textit{k} para uma permutação de um par já visitado.

De forma a determinar a distribuição de conectividades é necessário contar o número de pares de nós com conectividade $k$ para cada conectividade calculada. Para uma rede com $n$ nós, um par de nós tem no máximo uma conectividade de $(n - 2)$. 

\begin{algorithm}
\caption{Procedimento para calcular a distribuição cumulativa do menor número de nós que é necessário quebrar para separar um nó fonte de um nó destino}\label{alg:distribution}
\begin{algorithmic}[1]
\Procedure{getDistribution}{$graph$}
    \For{each connectivity $c$ in $range(0, nodeCount - 1)$}
    		\State $count[c] := 0$
    \EndFor
    
    \State $none := 0$ \Comment count of nodes that can't be disconnected
		
    \For{each pair of nodes uv}
    		\State $flow := MaximumFlow(graph, uv)$
    		\If{$flow$ is not $\infty$}
			\State $count[c] := count[c] + 1$
		\Else
			\State $none := none + 1$
		\EndIf
    \EndFor
    	
  	\Return $Distributions$
\EndProcedure
\end{algorithmic}
\end{algorithm}

A operação $getDistribution$ executa o algoritmo $MaximumFlow$ $n(n-1)/2$ vezes, logo a sua complexidade assimptótica é igual a: $O(n^2) * O(n m^2) = O(m^2 n^3)$.

\section{Conectividade da Rede}

Para determinar a conectividade da rede basta calcular a conectividade para todos os pares de nós, como se fez no caso da distribuição cumulativa, e determinar o(s) par(es) de nós com conectividade mais baixa (mínima).

Na última iteração do algoritmo da conectividade, para o par de nós com conectividade mais baixa, não é encontrado nenhum caminho da fonte para o destino, contudo o conjunto dos nós visitados durante a execução da BFS nessa iteração determina conjunto de nós que fazem parte do corte mínimo da rede. Uma vez que as ligação entre os dois sub-nós têm capacidade unitária e as ligações entre supernós capacidade infinita, o corte a travessa sempre a ligação entre sub-nós. Sendo assim, para determinar o conjunto de nós que separa a rede, basta procurar na lista de nós visitados que resulta dessa última iteração, os sub-nós negativos para os quais o respetivo sub-nó positivo não foi visitado (não se encontra no corte). O supernó respetivo é um nó que separa a rede.

A complexidade assimptótica desta operação é a mesma da anterior uma vez que é calculada a connectividade para cada par de nós.


\end{document}