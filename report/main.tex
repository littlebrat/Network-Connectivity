\documentclass[12pt,a4paper]{scrartcl}


\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{aeguill}
\usepackage{pbox}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{mathtools}
\usepackage{bmpsize}
\usepackage[toc,page]{appendix}
\linespread{1}

\begin{document}
\everymath{\displaystyle}
\pagenumbering{arabic}
\setcounter{page}{1}

\begin{titlepage}
	\begin{center}
		\hfill \break
		\hfill \break
		\includegraphics[scale = 0.35]{Logo}~\\[1cm]
		\textsc{\LARGE Instituto Superior Técnico}\\[0.25cm]
		\textsc{\Large Mestrado Integrado em Engenharia Electrotécnica e de Computadores}\\[1.8cm]
		\textsc{\huge Algoritmia e Desempenho Em Redes de Computadores}\\[0.25cm]
		{\huge \bfseries  Conectividade na Internet\\[1cm]}
		\begin{tabular}{ l l }
			David Fialho & \hspace{2mm} n.º 73530 \\
			Nuno Mendes & \hspace{2mm} n.º 73716 
		\end{tabular}
		\vfill
		{\large Lisboa, 4 de Dezembro de 2015}
	\end{center}
\end{titlepage}

\pagebreak

\section{O Problema}

Neste relatório é descrito um procedimento para calcular o número mínimo de nós retirados que impeça a rede de permanecer ligada. Para a resolução do problema é descrito um procedimento que funciona para qualquer grafo genérico.

A conectividade da rede é um parâmetro global desta e por isso, pode ser descrita como o mínimo número de nós removidos que separa um par fonte-destino dessa rede, no conjunto de todos os pares possíveis.

\section{Número de nós que separa um nó fonte de um nó destino}

\subsection{Descrição}
O problema de encontrar o menor número de nós que se tem de remover para separar a fonte do destino é equivalente a encontrar o número de caminhos disjuntos na rede entre este par.

Este problema pode então ser modulado como um problema de fluxos máximos, fazendo \textit{vertex-splitting} e atribuíndo à ligação interna do super-nó uma capacidade unitária. A todas as outras ligações da rede foi atribuída uma capacidade igual a infinito, apesar da estratégia também ser válida para uma capacidade unitária dessas mesmas ligações.

Para resolver o problema do fluxo máximo da rede foi utilizado o algoritmo de Edmonds-Karp, uma possível implementação do algoritmo de Ford-Fulkerson que utiliza uma BFS para encontrar primeiro os caminhos mais curtos em número de ligações da rede.


\subsection{Algoritmo}

\begin{algorithm}
\caption{Algoritmo BFS que procura um caminho entre o nó fonte \textit{s} e o destino \textit{t}.}\label{alg:bfs_goal}
\begin{algorithmic}[1]
\Procedure{GetPath}{$graph, source, goal$}
	\For{each node $n$ in $graph$}
    	\State {mark all nodes in $graph$ as not $visited$}
    	\State $parent[n] := \emptyset $
    \EndFor
    \State $Queue :=  \{destination\}$
  	\While{there is a $node$ in $Queue$}
      \State {select first node $u$ from $Queue$}
      \If{$u$ is $goal$}
      		\Return parent 
      \EndIf
      \For{each $link$ in $links[u]$}
      		\State {select tail node $v$ from $link$}
        	\If{$capacity(link)$ is $positive$ and $v$ not $visited$}
        		\State {mark $v$ as $visited$}
        		\State {mark $u$ as $parent$ of $v$}
            	\State {$Queue := Queue \cup \{v\}$}
            \EndIf
      \EndFor
  	\EndWhile
  	\Return $NULL$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Algoritmo Edmonds-Karp que calcula o fluxo máximo da rede.}\label{alg:residual_network}
\begin{algorithmic}[1]
\Procedure{MaximumFlow}{$graph, source, goal$}
    \State $maxflow := 0 $
    \State $path := GetPath(graph,source,goal)$
  	\While{there is a disjoint $path$ in $graph$}
      \For{each $link$ in $path$}
      		\State subtract 1 from $link$ capacity
        	\State add 1 to $inverted(link)$ capacity
      \EndFor
      \State add 1 to $maxflow$
      \State $path := GetPath(graph,source,goal)$
  	\EndWhile
  	\Return $maxflow$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Complexidade Assimptótica}

Para um grafo com n vértices e m arestas, podem existir m caminhos disjuntos do nó fonte para o nó terminal, sendo que no pior caso o algoritmo Edmonds-Karp vai percorrer m vezes o ciclo principal.
Tendo em conta que em cada iteração é executada uma BFS, que tem uma complexidade assimptótica de $O(n+m)$, o algoritmo no seu todo vai ter complexidade assimptótica de $O(m n^2)$.

\section{Distribuição cumulativa do número de nós que separam um nó fonte de um nó destino}

\subsection{Descrição}

\subsection{Algoritmo}

\begin{algorithm}
\caption{Procedimento para calcular a distribuição cumulativa do menor número de nós que é necessário quebrar para separar um nó fonte de um nó destino}\label{alg:distribution}
\begin{algorithmic}[1]
\Procedure{getDistribution}{$graph$}
	\State Initiate array $Distributions$ with length: $nodes - 2$
    \For{each node as $source$ in $graph$}
      \For{each node as $goal$ in $graph$ with $id(source)>id(goal)$}
          	  \State $flow := MaximumFlow(graph,source,goal)$
          	  \If{$flow$ is not $\infty$}
              	\State add 1 to all $k$ in $Distributions$ with $k \geq flow$
              \EndIf
      \EndFor
    \EndFor
  	\Return $Distributions$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Complexidade Assimptótica}

No pior

\section{Conectividade da Rede}

\subsection{Descrição}

\subsection{Algoritmo}

\subsection{Complexidade Assimptótica}

\end{document}