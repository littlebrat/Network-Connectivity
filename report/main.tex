\documentclass[12pt,a4paper]{scrartcl}


\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{aeguill}
\usepackage{pbox}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{mathtools}
\usepackage{bmpsize}
\usepackage[toc,page]{appendix}
\linespread{1}

\begin{document}
\everymath{\displaystyle}
\pagenumbering{arabic}
\setcounter{page}{1}

\begin{titlepage}
	\begin{center}
		\hfill \break
		\hfill \break
		\includegraphics[scale = 0.35]{Logo}~\\[1cm]
		\textsc{\LARGE Instituto Superior Técnico}\\[0.25cm]
		\textsc{\Large Mestrado Integrado em Engenharia Electrotécnica e de Computadores}\\[1.8cm]
		\textsc{\huge Algoritmia e Desempenho Em Redes de Computadores}\\[0.25cm]
		{\huge \bfseries  Conectividade na Internet\\[1cm]}
		\begin{tabular}{ l l }
			David Fialho & \hspace{2mm} n.º 73530 \\
			Nuno Mendes & \hspace{2mm} n.º 73716 
		\end{tabular}
		\vfill
		{\large Lisboa, 4 de Dezembro de 2015}
	\end{center}
\end{titlepage}

\pagebreak

\section{O Problema}

Neste relatório é descrito um procedimento para calcular o número mínimo de nós retirados que impeça a rede de permanecer ligada. Para a resolução do problema é descrito um procedimento que funciona para qualquer grafo genérico.

A conectividade da rede é um parâmetro global desta e por isso, pode ser descrita como o mínimo número de nós removidos que separa um par fonte-destino dessa rede, no conjunto de todos os pares possíveis.

O problema de encontrar o menor número de nós que se tem de remover para separar a fonte do destino é equivalente a encontrar o número de caminhos disjuntos na rede entre este par.

Este problema pode então ser modulado como um problema de fluxos máximos, fazendo \textit{vertex-splitting} e atribuíndo à ligação interna do super-nó uma capacidade unitária. A todas as outras ligações da rede foi atribuída uma capacidade igual a infinito, apesar da estratégia também ser válida para uma capacidade unitária dessas mesmas ligações.

\section{Número de nós que separa um nó fonte de um nó destino}

\subsection{Descrição}

\subsection{Algoritmo}

\begin{algorithm}
\caption{Algoritmo BFS que procura um caminho entre o nó fonte \textit{s} e o destino \textit{t}.}\label{alg:bfs_goal}
\begin{algorithmic}[1]
\Procedure{GetPath}{$graph, source, goal$}
	\For{each node $n$ in $graph$}
    	\State $visited[n] := False $
    	\State $parent[n] := \emptyset $
    \EndFor
    \State $Queue :=  \{destination\}$
  	\While{$Queue$ is not $empty$}
      \State {select first node $u$ from $queue$}
      \If{u = goal}
      		\Return parent 
      \EndIf
      \For{each $link$ in $links[u]$}
        	\State neighbour = link.tail
        	\If{$visited[neighbour]$ is $False$}
				\State $parent[neighbour] := u $
            	\State {$Queue := Queue \cup \{v\}$}
            \EndIf
      \EndFor
  	\EndWhile
  	\Return $NULL$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Algoritmo Ford-Fulkerson que calcula o fluxo máximo da rede.}\label{alg:residual_network}
\begin{algorithmic}[1]
\Procedure{GetResidualNetwork}{$graph, source, goal$}
    \State $maxflow := 0 $
    \State $path := GetPath(graph,source,goal)$
  	\While{$path$ is not $NULL$}
      \For{each $link$ in $path$}
        	\State $link.maxflow = link.maxflow - 1$
        	\State $reverse(link).maxflow = link.maxflow + 1$
      \EndFor
      \State $maxflow := maxflow + 1 $
      \State $path := GetPath(graph,source,goal)$
  	\EndWhile
  	\Return $maxflow$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Complexidade Assimptótica}

\section{Distribuição cumulativa do número de nós que separam um nó fonte de um nó destino}

\subsection{Descrição}

\subsection{Algoritmo}

\subsection{Complexidade Assimptótica}

\section{Conectividade da Rede}

\subsection{Descrição}

\subsection{Algoritmo}

\subsection{Complexidade Assimptótica}

\end{document}